(self.TURBOPACK = self.TURBOPACK || []).push(["chunks/ssr/node_modules_next_dist_lib_metadata_metadata.js", {

"[project-with-next]/node_modules/next/dist/lib/metadata/metadata.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, p: process, g: global, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Metadata = Metadata;
var _react = _interopRequireDefault(__turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/index.js (ecmascript, ssr)"));
var _basic = __turbopack_require__("[project-with-next]/node_modules/next/dist/lib/metadata/generate/basic.js (ecmascript, ssr)");
var _alternate = __turbopack_require__("[project-with-next]/node_modules/next/dist/lib/metadata/generate/alternate.js (ecmascript, ssr)");
var _opengraph = __turbopack_require__("[project-with-next]/node_modules/next/dist/lib/metadata/generate/opengraph.js (ecmascript, ssr)");
var _resolveMetadata = __turbopack_require__("[project-with-next]/node_modules/next/dist/lib/metadata/resolve-metadata.js (ecmascript, ssr)");
var _icons = __turbopack_require__("[project-with-next]/node_modules/next/dist/lib/metadata/generate/icons.js (ecmascript, ssr)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
async function Metadata({ metadata  }) {
    if (!metadata) return null;
    const resolved = await (0, _resolveMetadata).resolveMetadata(metadata);
    return _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_basic.BasicMetadata, {
        metadata: resolved
    }), _react.default.createElement(_alternate.AlternatesMetadata, {
        alternates: resolved.alternates
    }), _react.default.createElement(_basic.ItunesMeta, {
        itunes: resolved.itunes
    }), _react.default.createElement(_basic.FormatDetectionMeta, {
        formatDetection: resolved.formatDetection
    }), _react.default.createElement(_basic.AppleWebAppMeta, {
        appleWebApp: resolved.appleWebApp
    }), _react.default.createElement(_opengraph.OpenGraphMetadata, {
        openGraph: resolved.openGraph
    }), _react.default.createElement(_opengraph.TwitterMetadata, {
        twitter: resolved.twitter
    }), _react.default.createElement(_opengraph.AppLinksMeta, {
        appLinks: resolved.appLinks
    }), _react.default.createElement(_icons.IconsMetadata, {
        icons: resolved.icons
    }));
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/lib/metadata/generate/basic.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, p: process, g: global, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BasicMetadata = BasicMetadata;
exports.ItunesMeta = ItunesMeta;
exports.FormatDetectionMeta = FormatDetectionMeta;
exports.AppleWebAppMeta = AppleWebAppMeta;
var _react = _interopRequireDefault(__turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/index.js (ecmascript, ssr)"));
var _meta = __turbopack_require__("[project-with-next]/node_modules/next/dist/lib/metadata/generate/meta.js (ecmascript, ssr)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function BasicMetadata({ metadata  }) {
    var ref, ref1, ref2, ref3;
    return _react.default.createElement(_react.default.Fragment, null, _react.default.createElement("meta", {
        charSet: "utf-8"
    }), metadata.title !== null ? _react.default.createElement("title", null, metadata.title.absolute) : null, _react.default.createElement(_meta.Meta, {
        name: "description",
        content: metadata.description
    }), _react.default.createElement(_meta.Meta, {
        name: "application-name",
        content: metadata.applicationName
    }), _react.default.createElement(_meta.Meta, {
        name: "author",
        content: (ref = metadata.authors) == null ? void 0 : ref.join(",")
    }), _react.default.createElement(_meta.Meta, {
        name: "generator",
        content: metadata.generator
    }), _react.default.createElement(_meta.Meta, {
        name: "keywords",
        content: (ref1 = metadata.keywords) == null ? void 0 : ref1.join(",")
    }), _react.default.createElement(_meta.Meta, {
        name: "referrer",
        content: metadata.referrer
    }), _react.default.createElement(_meta.Meta, {
        name: "theme-color",
        content: metadata.themeColor
    }), _react.default.createElement(_meta.Meta, {
        name: "color-scheme",
        content: metadata.colorScheme
    }), _react.default.createElement(_meta.Meta, {
        name: "viewport",
        content: metadata.viewport
    }), _react.default.createElement(_meta.Meta, {
        name: "creator",
        content: metadata.creator
    }), _react.default.createElement(_meta.Meta, {
        name: "publisher",
        content: metadata.publisher
    }), _react.default.createElement(_meta.Meta, {
        name: "robots",
        content: (ref2 = metadata.robots) == null ? void 0 : ref2.basic
    }), _react.default.createElement(_meta.Meta, {
        name: "googlebot",
        content: (ref3 = metadata.robots) == null ? void 0 : ref3.googleBot
    }), _react.default.createElement(_meta.Meta, {
        name: "abstract",
        content: metadata.abstract
    }), metadata.archives ? metadata.archives.map((archive)=>_react.default.createElement("link", {
            rel: "archives",
            href: archive,
            key: archive
        })) : null, metadata.assets ? metadata.assets.map((asset)=>_react.default.createElement("link", {
            rel: "assets",
            href: asset,
            key: asset
        })) : null, metadata.bookmarks ? metadata.bookmarks.map((bookmark)=>_react.default.createElement("link", {
            rel: "bookmarks",
            href: bookmark,
            key: bookmark
        })) : null, _react.default.createElement(_meta.Meta, {
        name: "category",
        content: metadata.category
    }), _react.default.createElement(_meta.Meta, {
        name: "classification",
        content: metadata.classification
    }), metadata.other ? Object.entries(metadata.other).map(([name, content])=>_react.default.createElement(_meta.Meta, {
            key: name,
            name: name,
            content: Array.isArray(content) ? content.join(",") : content
        })) : null);
}
function ItunesMeta({ itunes  }) {
    if (!itunes) return null;
    const { appId , appArgument  } = itunes;
    let content = `app-id=${appId}`;
    if (appArgument) {
        content += `, app-argument=${appArgument}`;
    }
    return _react.default.createElement("meta", {
        name: "apple-itunes-app",
        content: content
    });
}
const formatDetectionKeys = [
    "telephone",
    "date",
    "address",
    "email",
    "url"
];
function FormatDetectionMeta({ formatDetection  }) {
    if (!formatDetection) return null;
    let content = "";
    for (const key of formatDetectionKeys){
        if (formatDetection[key]) {
            if (content) content += ", ";
            content += `${key}=no`;
        }
    }
    return _react.default.createElement("meta", {
        name: "format-detection",
        content: content
    });
}
function AppleWebAppMeta({ appleWebApp  }) {
    if (!appleWebApp) return null;
    const { capable , title , startupImage , statusBarStyle  } = appleWebApp;
    return _react.default.createElement(_react.default.Fragment, null, capable ? _react.default.createElement("meta", {
        name: "apple-mobile-web-app-capable",
        content: "yes"
    }) : null, title ? _react.default.createElement("meta", {
        name: "apple-mobile-web-app-title",
        content: title
    }) : null, startupImage ? startupImage.map((image, index)=>_react.default.createElement("link", {
            key: index,
            href: image.url,
            media: image.media,
            rel: "apple-touch-startup-image"
        })) : null, statusBarStyle ? _react.default.createElement("meta", {
        name: "apple-mobile-web-app-status-bar-style",
        content: statusBarStyle
    }) : null);
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/lib/metadata/generate/alternate.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, p: process, g: global, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AlternatesMetadata = AlternatesMetadata;
var _react = _interopRequireDefault(__turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/index.js (ecmascript, ssr)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function AlternatesMetadata({ alternates  }) {
    if (!alternates) return null;
    return _react.default.createElement(_react.default.Fragment, null, alternates.canonical ? _react.default.createElement("link", {
        rel: "canonical",
        href: alternates.canonical.toString()
    }) : null, Object.entries(alternates.languages).map(([locale, url])=>url ? _react.default.createElement("link", {
            key: locale,
            rel: "alternate",
            hrefLang: locale,
            href: url.toString()
        }) : null), alternates.media ? Object.entries(alternates.media).map(([media, url])=>url ? _react.default.createElement("link", {
            key: media,
            rel: "alternate",
            media: media,
            href: url.toString()
        }) : null) : null, alternates.types ? Object.entries(alternates.types).map(([type, url])=>url ? _react.default.createElement("link", {
            key: type,
            rel: "alternate",
            type: type,
            href: url.toString()
        }) : null) : null);
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/lib/metadata/generate/opengraph.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, p: process, g: global, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OpenGraphMetadata = OpenGraphMetadata;
exports.TwitterMetadata = TwitterMetadata;
exports.AppLinksMeta = AppLinksMeta;
var _react = _interopRequireDefault(__turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/index.js (ecmascript, ssr)"));
var _meta = __turbopack_require__("[project-with-next]/node_modules/next/dist/lib/metadata/generate/meta.js (ecmascript, ssr)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function OpenGraphMetadata({ openGraph  }) {
    var ref, ref1, ref2;
    if (!openGraph) {
        return null;
    }
    let typedOpenGraph;
    if ("type" in openGraph) {
        switch(openGraph.type){
            case "website":
                typedOpenGraph = _react.default.createElement(_meta.Meta, {
                    property: "og:type",
                    content: "website"
                });
                break;
            case "article":
                var ref3, ref4, ref5;
                typedOpenGraph = _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_meta.Meta, {
                    property: "og:type",
                    content: "article"
                }), _react.default.createElement(_meta.Meta, {
                    property: "article:published_time",
                    content: (ref3 = openGraph.publishedTime) == null ? void 0 : ref3.toString()
                }), _react.default.createElement(_meta.Meta, {
                    property: "article:modified_time",
                    content: (ref4 = openGraph.modifiedTime) == null ? void 0 : ref4.toString()
                }), _react.default.createElement(_meta.Meta, {
                    property: "article:expiration_time",
                    content: (ref5 = openGraph.expirationTime) == null ? void 0 : ref5.toString()
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "article:author",
                    contents: openGraph.authors
                }), _react.default.createElement(_meta.Meta, {
                    property: "article:section",
                    content: openGraph.section
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "article:tag",
                    contents: openGraph.tags
                }));
                break;
            case "book":
                typedOpenGraph = _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_meta.Meta, {
                    property: "og:type",
                    content: "book"
                }), _react.default.createElement(_meta.Meta, {
                    property: "book:isbn",
                    content: openGraph.isbn
                }), _react.default.createElement(_meta.Meta, {
                    property: "book:release_date",
                    content: openGraph.releaseDate
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "book:author",
                    contents: openGraph.authors
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "book:tag",
                    contents: openGraph.tags
                }));
                break;
            case "profile":
                typedOpenGraph = _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_meta.Meta, {
                    property: "og:type",
                    content: "profile"
                }), _react.default.createElement(_meta.Meta, {
                    property: "profile:first_name",
                    content: openGraph.firstName
                }), _react.default.createElement(_meta.Meta, {
                    property: "profile:last_name",
                    content: openGraph.lastName
                }), _react.default.createElement(_meta.Meta, {
                    property: "profile:username",
                    content: openGraph.username
                }), _react.default.createElement(_meta.Meta, {
                    property: "profile:gender",
                    content: openGraph.gender
                }));
                break;
            case "music.song":
                var ref6;
                typedOpenGraph = _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_meta.Meta, {
                    property: "og:type",
                    content: "music.song"
                }), _react.default.createElement(_meta.Meta, {
                    property: "music:duration",
                    content: (ref6 = openGraph.duration) == null ? void 0 : ref6.toString()
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "music:album",
                    contents: openGraph.albums
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "music:musician",
                    contents: openGraph.musicians
                }));
                break;
            case "music.album":
                typedOpenGraph = _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_meta.Meta, {
                    property: "og:type",
                    content: "music.album"
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "music:song",
                    contents: openGraph.songs
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "music:musician",
                    contents: openGraph.musicians
                }), _react.default.createElement(_meta.Meta, {
                    property: "music:release_date",
                    content: openGraph.releaseDate
                }));
                break;
            case "music.playlist":
                typedOpenGraph = _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_meta.Meta, {
                    property: "og:type",
                    content: "music.playlist"
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "music:song",
                    contents: openGraph.songs
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "music:creator",
                    contents: openGraph.creators
                }));
                break;
            case "music.radio_station":
                typedOpenGraph = _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_meta.Meta, {
                    property: "og:type",
                    content: "music.radio_station"
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "music:creator",
                    contents: openGraph.creators
                }));
                break;
            case "video.movie":
                typedOpenGraph = _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_meta.Meta, {
                    property: "og:type",
                    content: "video.movie"
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "video:actor",
                    contents: openGraph.actors
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "video:director",
                    contents: openGraph.directors
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "video:writer",
                    contents: openGraph.writers
                }), _react.default.createElement(_meta.Meta, {
                    property: "video:duration",
                    content: openGraph.duration
                }), _react.default.createElement(_meta.Meta, {
                    property: "video:release_date",
                    content: openGraph.releaseDate
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "video:tag",
                    contents: openGraph.tags
                }));
                break;
            case "video.episode":
                typedOpenGraph = _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_meta.Meta, {
                    property: "og:type",
                    content: "video.episode"
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "video:actor",
                    contents: openGraph.actors
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "video:director",
                    contents: openGraph.directors
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "video:writer",
                    contents: openGraph.writers
                }), _react.default.createElement(_meta.Meta, {
                    property: "video:duration",
                    content: openGraph.duration
                }), _react.default.createElement(_meta.Meta, {
                    property: "video:release_date",
                    content: openGraph.releaseDate
                }), _react.default.createElement(_meta.MultiMeta, {
                    propertyPrefix: "video:tag",
                    contents: openGraph.tags
                }), _react.default.createElement(_meta.Meta, {
                    property: "video:series",
                    content: openGraph.series
                }));
                break;
            case "video.tv_show":
                typedOpenGraph = _react.default.createElement(_meta.Meta, {
                    property: "og:type",
                    content: "video.tv_show"
                });
                break;
            case "video.other":
                typedOpenGraph = _react.default.createElement(_meta.Meta, {
                    property: "og:type",
                    content: "video.other"
                });
                break;
            default:
                throw new Error("Invalid OpenGraph type: " + openGraph.type);
        }
    }
    return _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_meta.Meta, {
        property: "og:determiner",
        content: openGraph.determiner
    }), _react.default.createElement(_meta.Meta, {
        property: "og:title",
        content: (ref = openGraph.title) == null ? void 0 : ref.absolute
    }), _react.default.createElement(_meta.Meta, {
        property: "og:description",
        content: openGraph.description
    }), _react.default.createElement(_meta.Meta, {
        property: "og:url",
        content: (ref1 = openGraph.url) == null ? void 0 : ref1.toString()
    }), _react.default.createElement(_meta.Meta, {
        property: "og:site_name",
        content: openGraph.siteName
    }), _react.default.createElement(_meta.Meta, {
        property: "og:locale",
        content: openGraph.locale
    }), _react.default.createElement(_meta.Meta, {
        property: "og:country_name",
        content: openGraph.countryName
    }), _react.default.createElement(_meta.Meta, {
        property: "og:ttl",
        content: (ref2 = openGraph.ttl) == null ? void 0 : ref2.toString()
    }), _react.default.createElement(_meta.MultiMeta, {
        propertyPrefix: "og:image",
        contents: openGraph.images
    }), _react.default.createElement(_meta.MultiMeta, {
        propertyPrefix: "og:video",
        contents: openGraph.videos
    }), _react.default.createElement(_meta.MultiMeta, {
        propertyPrefix: "og:audio",
        contents: openGraph.audio
    }), _react.default.createElement(_meta.MultiMeta, {
        propertyPrefix: "og:email",
        contents: openGraph.emails
    }), _react.default.createElement(_meta.MultiMeta, {
        propertyPrefix: "og:phone_number",
        contents: openGraph.phoneNumbers
    }), _react.default.createElement(_meta.MultiMeta, {
        propertyPrefix: "og:fax_number",
        contents: openGraph.faxNumbers
    }), _react.default.createElement(_meta.MultiMeta, {
        propertyPrefix: "og:locale:alternate",
        contents: openGraph.alternateLocale
    }), typedOpenGraph);
}
function TwitterAppItem({ app , type  }) {
    return _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_meta.Meta, {
        name: `twitter:app:name:${type}`,
        content: app.name
    }), _react.default.createElement(_meta.ExtendMeta, {
        namePrefix: "twitter:app:id",
        content: app.id
    }), _react.default.createElement(_meta.ExtendMeta, {
        namePrefix: "twitter:app:url",
        content: app.url
    }));
}
function TwitterMetadata({ twitter  }) {
    var ref;
    if (!twitter) return null;
    const { card  } = twitter;
    return _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_meta.Meta, {
        name: "twitter:card",
        content: card
    }), _react.default.createElement(_meta.Meta, {
        name: "twitter:site",
        content: twitter.site
    }), _react.default.createElement(_meta.Meta, {
        name: "twitter:site:id",
        content: twitter.siteId
    }), _react.default.createElement(_meta.Meta, {
        name: "twitter:creator",
        content: twitter.creator
    }), _react.default.createElement(_meta.Meta, {
        name: "twitter:creator:id",
        content: twitter.creatorId
    }), _react.default.createElement(_meta.Meta, {
        name: "twitter:title",
        content: (ref = twitter.title) == null ? void 0 : ref.absolute
    }), _react.default.createElement(_meta.Meta, {
        name: "twitter:description",
        content: twitter.description
    }), twitter.images ? twitter.images.map((image)=>_react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_meta.Meta, {
            name: "twitter:image",
            content: image.url
        }), _react.default.createElement(_meta.Meta, {
            name: "twitter:image:alt",
            content: image.alt
        }))) : null, card === "player" ? twitter.players.map((player)=>_react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_meta.Meta, {
            name: "twitter:player",
            content: player.playerUrl.toString()
        }), _react.default.createElement(_meta.Meta, {
            name: "twitter:player:stream",
            content: player.streamUrl.toString()
        }), _react.default.createElement(_meta.Meta, {
            name: "twitter:player:width",
            content: player.width
        }), _react.default.createElement(_meta.Meta, {
            name: "twitter:player:height",
            content: player.height
        }))) : null, card === "app" ? _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(TwitterAppItem, {
        app: twitter.app,
        type: "iphone"
    }), _react.default.createElement(TwitterAppItem, {
        app: twitter.app,
        type: "ipad"
    }), _react.default.createElement(TwitterAppItem, {
        app: twitter.app,
        type: "googleplay"
    })) : null);
}
function AppLinksMeta({ appLinks  }) {
    if (!appLinks) return null;
    return _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_meta.MultiMeta, {
        propertyPrefix: "al:ios",
        contents: appLinks.ios
    }), _react.default.createElement(_meta.MultiMeta, {
        propertyPrefix: "al:iphone",
        contents: appLinks.iphone
    }), _react.default.createElement(_meta.MultiMeta, {
        propertyPrefix: "al:ipad",
        contents: appLinks.ipad
    }), _react.default.createElement(_meta.MultiMeta, {
        propertyPrefix: "al:android",
        contents: appLinks.android
    }), _react.default.createElement(_meta.MultiMeta, {
        propertyPrefix: "al:windows_phone",
        contents: appLinks.windows_phone
    }), _react.default.createElement(_meta.MultiMeta, {
        propertyPrefix: "al:windows",
        contents: appLinks.windows
    }), _react.default.createElement(_meta.MultiMeta, {
        propertyPrefix: "al:windows_universal",
        contents: appLinks.windows_universal
    }), _react.default.createElement(_meta.MultiMeta, {
        propertyPrefix: "al:web",
        contents: appLinks.web
    }));
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/lib/metadata/resolve-metadata.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, p: process, g: global, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.resolveMetadata = resolveMetadata;
exports.resolveFileBasedMetadataForLoader = resolveFileBasedMetadataForLoader;
var _defaultMetadata = __turbopack_require__("[project-with-next]/node_modules/next/dist/lib/metadata/default-metadata.js (ecmascript, ssr)");
var _resolveOpengraph = __turbopack_require__("[project-with-next]/node_modules/next/dist/lib/metadata/resolve-opengraph.js (ecmascript, ssr)");
var _resolveTitle = __turbopack_require__("[project-with-next]/node_modules/next/dist/lib/metadata/resolve-title.js (ecmascript, ssr)");
var _utils = __turbopack_require__("[project-with-next]/node_modules/next/dist/lib/metadata/generate/utils.js (ecmascript, ssr)");
const viewPortKeys = {
    width: "width",
    height: "height",
    initialScale: "initial-scale",
    minimumScale: "minimum-scale",
    maximumScale: "maximum-scale",
    viewportFit: "viewport-fit"
};
const resolveViewport = (viewport)=>{
    let resolved = null;
    if (typeof viewport === "string") {
        resolved = viewport;
    } else if (viewport) {
        resolved = "";
        for(const viewportKey_ in viewPortKeys){
            const viewportKey = viewportKey_;
            if (viewport[viewportKey]) {
                if (resolved) resolved += ", ";
                resolved += `${viewPortKeys[viewportKey]}=${viewport[viewportKey]}`;
            }
        }
    }
    return resolved;
};
const resolveVerification = (verification)=>{
    const google = (0, _utils).resolveAsArrayOrUndefined(verification == null ? void 0 : verification.google);
    const yahoo = (0, _utils).resolveAsArrayOrUndefined(verification == null ? void 0 : verification.yahoo);
    let other;
    if (verification == null ? void 0 : verification.other) {
        other = {};
        for(const key in verification.other){
            const value = (0, _utils).resolveAsArrayOrUndefined(verification.other[key]);
            if (value) other[key] = value;
        }
    }
    return {
        google,
        yahoo,
        other
    };
};
function isStringOrURL(icon) {
    return typeof icon === "string" || icon instanceof URL;
}
function resolveIcon(icon) {
    if (isStringOrURL(icon)) return {
        url: icon
    };
    else if (Array.isArray(icon)) return icon;
    return icon;
}
const IconKeys = [
    "icon",
    "shortcut",
    "apple",
    "other"
];
const TwitterBasicInfoKeys = [
    "site",
    "siteId",
    "creator",
    "creatorId",
    "description"
];
const resolveIcons = (icons)=>{
    if (!icons) {
        return null;
    }
    const resolved = {};
    if (Array.isArray(icons)) {
        resolved.icon = icons.map(resolveIcon).filter(Boolean);
    } else if (isStringOrURL(icons)) {
        resolved.icon = [
            resolveIcon(icons)
        ];
    } else {
        for (const key of IconKeys){
            const values = (0, _utils).resolveAsArrayOrUndefined(icons[key]);
            if (values) resolved[key] = values.map(resolveIcon);
        }
    }
    return resolved;
};
const resolveAppleWebApp = (appWebApp)=>{
    var ref;
    if (!appWebApp) return null;
    if (appWebApp === true) {
        return {
            capable: true
        };
    }
    const startupImages = (ref = (0, _utils).resolveAsArrayOrUndefined(appWebApp.startupImage)) == null ? void 0 : ref.map((item)=>typeof item === "string" ? {
            url: item
        } : item);
    return {
        capable: "capable" in appWebApp ? !!appWebApp.capable : true,
        title: appWebApp.title || null,
        startupImage: startupImages || null,
        statusBarStyle: appWebApp.statusBarStyle || "default"
    };
};
const resolveTwitter = (twitter)=>{
    var ref;
    if (!twitter) return null;
    const resolved = {
        title: twitter.title
    };
    for (const infoKey of TwitterBasicInfoKeys){
        resolved[infoKey] = twitter[infoKey] || null;
    }
    resolved.images = (ref = (0, _utils).resolveAsArrayOrUndefined(twitter.images)) == null ? void 0 : ref.map((item)=>{
        if (isStringOrURL(item)) return {
            url: item.toString()
        };
        else {
            return {
                url: item.url.toString(),
                alt: item.alt
            };
        }
    });
    if ("card" in twitter) {
        resolved.card = twitter.card;
        switch(twitter.card){
            case "player":
                {
                    resolved.players = (0, _utils).resolveAsArrayOrUndefined(twitter.players) || [];
                    break;
                }
            case "app":
                {
                    resolved.app = twitter.app || {};
                    break;
                }
            default:
                break;
        }
    } else {
        resolved.card = "summary";
    }
    return resolved;
};
const resolveAppLinks = (appLinks)=>{
    if (!appLinks) return null;
    for(const key in appLinks){
        appLinks[key] = (0, _utils).resolveAsArrayOrUndefined(appLinks[key]);
    }
    return appLinks;
};
const resolveRobotsValue = (robots)=>{
    if (!robots) return null;
    if (typeof robots === "string") return robots;
    const values = [];
    if (robots.index) values.push("index");
    else if (typeof robots.index === "boolean") values.push("noindex");
    if (robots.follow) values.push("follow");
    else if (typeof robots.follow === "boolean") values.push("nofollow");
    if (robots.noarchive) values.push("noarchive");
    if (robots.nosnippet) values.push("nosnippet");
    if (robots.noimageindex) values.push("noimageindex");
    if (robots.nocache) values.push("nocache");
    return values.join(", ");
};
const resolveRobots = (robots)=>{
    if (!robots) return null;
    return {
        basic: resolveRobotsValue(robots),
        googleBot: typeof robots !== "string" ? resolveRobotsValue(robots.googleBot) : null
    };
};
function merge(target, source, templateStrings) {
    for(const key_ in source){
        const key = key_;
        switch(key){
            case "title":
                {
                    if (source.title) {
                        target.title = source.title;
                        (0, _resolveTitle).mergeTitle(target, templateStrings.title);
                    }
                    break;
                }
            case "openGraph":
                {
                    if (typeof source.openGraph !== "undefined") {
                        target.openGraph = (0, _resolveOpengraph).resolveOpenGraph(source.openGraph);
                        if (source.openGraph) {
                            (0, _resolveTitle).mergeTitle(target.openGraph, templateStrings.openGraph);
                        }
                    } else {
                        target.openGraph = null;
                    }
                    break;
                }
            case "twitter":
                {
                    target.twitter = resolveTwitter(source.twitter);
                    if (target.twitter) {
                        (0, _resolveTitle).mergeTitle(target.twitter, templateStrings.twitter);
                    }
                    break;
                }
            case "verification":
                target.verification = resolveVerification(source.verification);
                break;
            case "viewport":
                {
                    target.viewport = resolveViewport(source.viewport);
                    break;
                }
            case "icons":
                {
                    target.icons = resolveIcons(source.icons);
                    break;
                }
            case "appleWebApp":
                target.appleWebApp = resolveAppleWebApp(source.appleWebApp);
                break;
            case "appLinks":
                target.appLinks = resolveAppLinks(source.appLinks);
                break;
            case "robots":
                {
                    target.robots = resolveRobots(source.robots);
                    break;
                }
            case "archives":
            case "assets":
            case "bookmarks":
            case "keywords":
            case "authors":
                {
                    target[key] = (0, _utils).resolveAsArrayOrUndefined(source[key]) || null;
                    break;
                }
            case "applicationName":
            case "description":
            case "generator":
            case "themeColor":
            case "creator":
            case "publisher":
            case "category":
            case "classification":
            case "referrer":
            case "colorScheme":
            case "itunes":
            case "alternates":
            case "formatDetection":
            case "other":
                target[key] = source[key] || null;
                break;
            default:
                break;
        }
    }
}
async function resolveMetadata(metadataItems) {
    const resolvedMetadata = (0, _defaultMetadata).createDefaultMetadata();
    let committedTitleTemplate = null;
    let committedOpenGraphTitleTemplate = null;
    let committedTwitterTitleTemplate = null;
    let lastLayer = 0;
    for(let i = 0; i < metadataItems.length; i++){
        const item = metadataItems[i];
        const isLayout = item.type === "layout";
        const isPage = item.type === "page";
        if (isLayout || isPage) {
            let layerMod = await item.mod();
            if ("$$typeof" in layerMod && layerMod.$$typeof === Symbol.for("react.module.reference")) {
                continue;
            }
            if (layerMod.metadata && layerMod.generateMetadata) {
                throw new Error(`A ${item.type} is exporting both metadata and generateMetadata which is not supported. If all of the metadata you want to associate to this ${item.type} is static use the metadata export, otherwise use generateMetadata. File: ` + item.path);
            }
            if (item.layer >= lastLayer) {
                var ref, ref1, ref2, ref3, ref4;
                committedTitleTemplate = ((ref = resolvedMetadata.title) == null ? void 0 : ref.template) || null;
                committedOpenGraphTitleTemplate = ((ref1 = resolvedMetadata.openGraph) == null ? void 0 : (ref2 = ref1.title) == null ? void 0 : ref2.template) || null;
                committedTwitterTitleTemplate = ((ref3 = resolvedMetadata.twitter) == null ? void 0 : (ref4 = ref3.title) == null ? void 0 : ref4.template) || null;
                lastLayer = item.layer;
            }
            if (layerMod.metadata) {
                merge(resolvedMetadata, layerMod.metadata, {
                    title: committedTitleTemplate,
                    openGraph: committedOpenGraphTitleTemplate,
                    twitter: committedTwitterTitleTemplate
                });
            } else if (layerMod.generateMetadata) {
                merge(resolvedMetadata, await layerMod.generateMetadata({}, Promise.resolve(resolvedMetadata)), {
                    title: committedTitleTemplate,
                    openGraph: committedOpenGraphTitleTemplate,
                    twitter: committedTwitterTitleTemplate
                });
            }
        }
    }
    return resolvedMetadata;
}
async function resolveFileBasedMetadataForLoader(_layer, _dir) {
    let metadataCode = "";
    return metadataCode;
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/lib/metadata/generate/icons.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, p: process, g: global, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IconsMetadata = IconsMetadata;
var _react = _interopRequireDefault(__turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/index.js (ecmascript, ssr)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const resolveUrl = (url)=>typeof url === "string" ? url : url.toString();
function IconDescriptorLink({ icon  }) {
    const { url , rel ="icon" , ...props } = icon;
    return _react.default.createElement("link", Object.assign({
        rel: rel,
        href: resolveUrl(url)
    }, props));
}
function IconLink({ rel , icon  }) {
    if (typeof icon === "object" && !(icon instanceof URL)) {
        if (rel) icon.rel = rel;
        return _react.default.createElement(IconDescriptorLink, {
            icon: icon
        });
    } else {
        const href = resolveUrl(icon);
        return _react.default.createElement("link", {
            rel: rel,
            href: href
        });
    }
}
function IconsMetadata({ icons  }) {
    if (!icons) return null;
    const shortcutList = icons.shortcut;
    const iconList = icons.icon;
    const appleList = icons.apple;
    const otherList = icons.other;
    return _react.default.createElement(_react.default.Fragment, null, shortcutList ? shortcutList.map((icon, index)=>_react.default.createElement(IconLink, {
            key: `shortcut-${index}`,
            rel: "shortcut icon",
            icon: icon
        })) : null, iconList ? iconList.map((icon, index)=>_react.default.createElement(IconLink, {
            key: `shortcut-${index}`,
            rel: "icon",
            icon: icon
        })) : null, appleList ? appleList.map((icon, index)=>_react.default.createElement(IconLink, {
            key: `apple-${index}`,
            rel: "apple-touch-icon",
            icon: icon
        })) : null, otherList ? otherList.map((icon, index)=>_react.default.createElement(IconDescriptorLink, {
            key: `other-${index}`,
            icon: icon
        })) : null);
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/lib/metadata/generate/meta.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, p: process, g: global, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Meta = Meta;
exports.ExtendMeta = ExtendMeta;
exports.MultiMeta = MultiMeta;
var _react = _interopRequireDefault(__turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/index.js (ecmascript, ssr)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function Meta({ name , property , content  }) {
    if (typeof content !== "undefined" && content !== null) {
        return _react.default.createElement("meta", Object.assign({}, name ? {
            name
        } : {
            property
        }, {
            content: typeof content === "string" ? content : content.toString()
        }));
    }
    return null;
}
function ExtendMeta({ content , namePrefix , propertyPrefix  }) {
    const keyPrefix = namePrefix || propertyPrefix;
    if (!content) return null;
    return _react.default.createElement(_react.default.Fragment, null, Object.entries(content).map(([k, v], index)=>{
        return typeof v === "undefined" ? null : _react.default.createElement(Meta, Object.assign({
            key: keyPrefix + ":" + k + "_" + index
        }, propertyPrefix ? {
            property: propertyPrefix + ":" + k
        } : {
            name: namePrefix + ":" + k
        }, {
            content: typeof v === "string" ? v : v == null ? void 0 : v.toString()
        }));
    }));
}
function MultiMeta({ propertyPrefix , namePrefix , contents  }) {
    if (typeof contents === "undefined" || contents === null) {
        return null;
    }
    const keyPrefix = propertyPrefix || namePrefix;
    return _react.default.createElement(_react.default.Fragment, null, contents.map((content, index)=>{
        if (typeof content === "string" || typeof content === "number" || content instanceof URL) {
            return _react.default.createElement(Meta, Object.assign({
                key: keyPrefix + "_" + index
            }, propertyPrefix ? {
                property: propertyPrefix
            } : {
                name: namePrefix
            }, {
                content: content
            }));
        } else {
            return _react.default.createElement(ExtendMeta, {
                namePrefix: namePrefix,
                propertyPrefix: propertyPrefix,
                content: content
            });
        }
    }));
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/lib/metadata/default-metadata.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, p: process, g: global, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createDefaultMetadata = void 0;
const createDefaultMetadata = ()=>{
    return {
        viewport: "width=device-width, initial-scale=1",
        metadataBase: null,
        title: null,
        description: null,
        applicationName: null,
        authors: null,
        generator: null,
        keywords: null,
        referrer: null,
        themeColor: null,
        colorScheme: null,
        creator: null,
        publisher: null,
        robots: null,
        alternates: {
            canonical: null,
            languages: {}
        },
        icons: null,
        openGraph: null,
        twitter: null,
        verification: {},
        appleWebApp: null,
        formatDetection: null,
        itunes: null,
        abstract: null,
        appLinks: null,
        archives: null,
        assets: null,
        bookmarks: null,
        category: null,
        classification: null,
        other: {}
    };
};
exports.createDefaultMetadata = createDefaultMetadata;

}.call(this) }),
"[project-with-next]/node_modules/next/dist/lib/metadata/resolve-opengraph.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, p: process, g: global, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.resolveOpenGraph = resolveOpenGraph;
var _utils = __turbopack_require__("[project-with-next]/node_modules/next/dist/lib/metadata/generate/utils.js (ecmascript, ssr)");
const OgTypFields = {
    article: [
        "authors",
        "tags"
    ],
    song: [
        "albums",
        "musicians"
    ],
    playlist: [
        "albums",
        "musicians"
    ],
    radio: [
        "creators"
    ],
    video: [
        "actors",
        "directors",
        "writers",
        "tags"
    ],
    basic: [
        "emails",
        "phoneNumbers",
        "faxNumbers",
        "alternateLocale",
        "images",
        "audio",
        "videos"
    ]
};
function getFieldsByOgType(ogType) {
    switch(ogType){
        case "article":
        case "book":
            return OgTypFields.article;
        case "music.song":
        case "music.album":
            return OgTypFields.song;
        case "music.playlist":
            return OgTypFields.playlist;
        case "music.radio_station":
            return OgTypFields.radio;
        case "video.movie":
        case "video.episode":
            return OgTypFields.video;
        default:
            return OgTypFields.basic;
    }
}
function resolveOpenGraph(openGraph) {
    const url = openGraph ? typeof openGraph.url === "string" ? new URL(openGraph.url) : openGraph.url : undefined;
    const resolved = openGraph || {};
    function assignProps(og) {
        const ogType = og && "type" in og ? og.type : undefined;
        const keys = getFieldsByOgType(ogType);
        for (const k of keys){
            const key = k;
            if (key in og) {
                const value = (0, _utils).resolveAsArrayOrUndefined(og[key]);
                if (value != null) {
                    resolved[key] = value;
                }
            }
        }
    }
    if (openGraph) {
        assignProps(openGraph);
    }
    if (url) {
        resolved.url = url;
    }
    return resolved;
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/lib/metadata/resolve-title.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, p: process, g: global, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeTitle = mergeTitle;
function resolveTitleTemplate(template, title) {
    return template ? template.replace(/%s/g, title) : title;
}
function mergeTitle(source, stashedTemplate) {
    const { title  } = source;
    let resolved;
    const template = typeof source.title !== "string" && source.title && "template" in source.title ? source.title.template : null;
    if (typeof title === "string") {
        resolved = resolveTitleTemplate(stashedTemplate, title);
    } else if (title) {
        if ("default" in title) {
            resolved = resolveTitleTemplate(stashedTemplate, title.default);
        }
        if ("absolute" in title && title.absolute) {
            resolved = title.absolute;
        }
    }
    const target = source;
    if (source.title && typeof source.title !== "string") {
        const targetTitle = source.title;
        targetTitle.template = template;
        targetTitle.absolute = resolved || "";
    } else {
        target.title = {
            absolute: resolved || source.title || "",
            template
        };
    }
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/lib/metadata/generate/utils.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, p: process, g: global, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.resolveAsArrayOrUndefined = resolveAsArrayOrUndefined;
function resolveAsArrayOrUndefined(value) {
    if (typeof value === "undefined" || value === null) {
        return undefined;
    }
    if (Array.isArray(value)) {
        return value;
    }
    return [
        value
    ];
}

}.call(this) }),
}]);


//# sourceMappingURL=node_modules_next_dist_lib_metadata_metadata.js.map